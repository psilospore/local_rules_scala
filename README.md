# Scala rules builds with Bloop

I am currently attempting a Bloop integration with the Scala rules for Bazel.
This repo demonstrates what happens with the bloop integration.
Running `bazel build //...` will build all targets and generate a `.bloop`.
I will commit .bloop to demonstrate the output generated by my changes.
Find more details in the offical PR (to be posted).

## Scenarios
I have a few builds each in their own folders that represent a variety of possible builds.

### ABC âœ…
A basic linear depedency graph

C_run -> C -> B -> A

### BC_Z_disjoint âœ…

2 disjoint dependency graphs

1) C_run -> C -> B

2) Z_run -> Z

Bloop config should not have anything shared between both graphs.

bloop runner walks through the 2 cases in parallel

### ABC_ERROR ðŸš§
A basic linear depedency graph but it has a compilation error

C_run -> C -> B -> A

### ABC_Java ðŸš§

C_run -> C -> B -> A (java)

### ABC_no_bloop âœ…

The current behavior.
Same linear depedency graph but compile without bloop.
Metals wont work

C_run -> C -> B -> A

## Metals Aside

Metals works automatically. It probably picks up that there's .bloop folder and handles it. For better integration I could have Metals run `bazel build //...` on Metals -> Import build.

However that would only happen if I choose to compile with bloop.
I spoke to Ittai about seperating the bloop generation into it's own phase. That way you can get metals support without compiling with bloop, but it's not so straightforward. Yuriy Yarosh suggested a completely different approach. I need to research that option more.

For the meantime maybe we could just have Metals detect if scala_with_bloop is used and run `bazel build //...` on Metals -> Import build. On a second iteration we could figure out the other case.
